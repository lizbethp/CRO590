# -*- coding: utf-8 -*-import arcpyimport osfrom arcpy.sa import *import pandas as pdfrom pathlib import Patharcpy.env.overwriteOutput = Truearcpy.CheckOutExtension('Spatial')class Toolbox(object):    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "Field Attribute Proessing"        self.alias = "FAprocessing"        # List of tool classes associated with this toolbox        self.tools = [FieldAttributeAddition]class FieldAttributeAddition(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Field Attribute Addition"        self.description = "Purpose:Automating data processing so that the final output contains all field attributes that can influence yield performance. The fields that will be added include elevation class (0 being the lowest point of the field), soil type, and treatment information (machinery settings and field practices). This tools generates a new fc."        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        param0 = arcpy.Parameter(            displayName = "Digital Acre shapefile",            name = 'DA_Dataset',            datatype = "GPFeatureLayer",            parameterType = "Required",            direction = "Input")        param1 = arcpy.Parameter(            displayName = "Row Number Field",            name = 'row_number',            datatype = "Field",            parameterType = "Required",            direction = "Input")        param1.parameterDependencies = [param0.name]        param2 = arcpy.Parameter(            displayName = "DEM",            name = 'DEM',            datatype = "GPRasterLayer",            parameterType = "Required",            direction = "Input")        param3 = arcpy.Parameter(            displayName = "Soil Survey Data",            name = 'soil',            datatype = "GPFeatureLayer",            parameterType = "Required",            direction = "Input")        param4 = arcpy.Parameter(            displayName = "Excel with Treatments Info",            name = 'treat',            datatype = "DEFile",            parameterType = "Required",            direction = "Input")        param5 = arcpy.Parameter(            displayName = "Output Updated Feature Class",            name = 'output_fc',            datatype = "GPFeatureLayer",            parameterType = "Required",            direction = "Output")        params = [param0, param1, param2, param3, param4, param5]                return params    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        input_fc = parameters[0].valueAsText        rownumb = parameters[1].valueAsText        dem = parameters[2].valueAsText        soil = parameters[3].valueAsText        treat_excel = parameters[4].valueAsText        outputpath = parameters[5].valueAsText        def dem_to_elvclass(dem, input_fc):            arcpy.env.workspace = 'memory'            # Clip DEM to extent of field             field_dem = arcpy.management.Clip(dem, "", 'field_dem', input_fc, maintain_clipping_extent = 'MAINTAIN_EXTENT' )            # Unit conversion (cm to meters)            fdem_m = Divide(field_dem, 100)            # Gets many unique levelation the raster has            raster_unique = int(arcpy.management.GetRasterProperties(fdem_m, 'UNIQUEVALUECOUNT').getOutput(0))            # Generates Remap Values             raster_value = []            elev_class = []            remap_values = []            # For every unique raster value (1 m increase) generate remap values            for i in range(raster_unique):                raster_value.append(fdem_m.minimum + i)                elev_class.append(i)            # Formats remap values             for a,b in zip(raster_value,elev_class):                remap_values.append([a,b])            outReclass = Reclassify(fdem_m, "Value", RemapValue(remap_values))                        return outReclass        start = time.perf_counter()                arcpy.AddMessage('Processing DEM')        # Processing DEM from elevation to elevation classes        inPointFeatures = input_fc        inRaster = dem_to_elvclass(dem, input_fc)        all_name = Path(input_fc)        file_name = all_name.stem        arcpy.AddMessage('Adding elevation classes to ' + str(os.path.basename(input_fc)))        # Adding elevation classes to shapefile         fc_w_elevclass = ExtractValuesToPoints(inPointFeatures, inRaster, file_name + '_elevclass', None, "VALUE_ONLY")        arcpy.AddMessage('Adding Soil Types to ' + str(os.path.basename(input_fc)))        # Adding Soil Type to input_fc        target_features = fc_w_elevclass        join_features = soil        out_fc = file_name + '_elevclass_soil'        fc_w_elev_soil = arcpy.analysis.SpatialJoin(target_features, join_features, out_fc)        arcpy.AddMessage('Adding treatment information to ' + str(os.path.basename(input_fc)))        #Import Data from Excel        treat_info = pd.read_excel(treat_excel)        # Create dictionaries for each treatment name/ info        treat_name = {}        avv_number = {}        tillage_in = {}        tllage_class = {}        depth_in = {}        depth_class = {}        downforce_lbs = {}        downforce_class = {}        cp_notch = {}        cp_class = {}        for i in range(len(treat_info)):            rows = treat_info.iloc[i]['Rows'].split(',')            for row in rows:                treat_name[int(row)] = treat_info.iloc[i]['Name']                avv_number[int(row)] = treat_info.iloc[i]['Number AV_V']                tillage_in[int(row)] = treat_info.iloc[i]['Tillage_in']                tllage_class[int(row)] = treat_info.iloc[i]['Tillage Class']                depth_in[int(row)] = treat_info.iloc[i]['Depth_in']                depth_class[int(row)] = treat_info.iloc[i]['Depth Class']                downforce_lbs[int(row)] = treat_info.iloc[i]['Downforce_lbs']                downforce_class[int(row)] = treat_info.iloc[i]['Downforce Class']                cp_notch[int(row)] = treat_info.iloc[i]['Clossing Pressure_notch']                cp_class[int(row)] = treat_info.iloc[i]['Clossing Class']        # Set local variables - AddField        inFeatures = fc_w_elev_soil        field_type1 = "TEXT"        fieldLength = 125        field_type2 = "SHORT"        fieldName1 = "T_Name"        fieldName2 = "T_AVV_Num"        fieldName3 = "T_Till_in"        fieldName4 = "T_Till_Class"        fieldName5 = "T_Depth_in"        fieldName6 = "T_Depth_Class"        fieldName7 = "T_Down_lbs"        fieldName8 = "T_Down_Class"        fieldName9 = "T_CP_notch"        fieldName10 = "T_CP_Class"        # Run AddField         arcpy.management.AddField(inFeatures, fieldName1, field_type1,                                   field_length=fieldLength)        arcpy.management.AddField(inFeatures, fieldName2, field_type2)        arcpy.management.AddField(inFeatures, fieldName3, field_type2)        arcpy.management.AddField(inFeatures, fieldName4, field_type1,                                   field_length=fieldLength)        arcpy.management.AddField(inFeatures, fieldName5, field_type2)        arcpy.management.AddField(inFeatures, fieldName6, field_type1,                                   field_length=fieldLength)        arcpy.management.AddField(inFeatures, fieldName7, field_type2)        arcpy.management.AddField(inFeatures, fieldName8, field_type1,                                   field_length=fieldLength)        arcpy.management.AddField(inFeatures, fieldName9, field_type2)        arcpy.management.AddField(inFeatures, fieldName10, field_type1,                                   field_length=fieldLength)        # Updating fc fields        fc = fc_w_elev_soil        fields = [rownumb, 'T_Name', 'T_AVV_Num', 'T_Till_in', 'T_Till_Class', 'T_Depth_in',                   'T_Depth_Class', 'T_Down_lbs', 'T_Down_Class', 'T_CP_notch', 'T_CP_Class']        # Create update cursor for feature class         with arcpy.da.UpdateCursor(fc, fields) as cursor:            # For each row, evaluate the Row_Numb value (index position             # of 0), and update Treatment, T_Tillage, T_Depth, T_Downforce             for row in cursor:                row[1] = treat_name[row[0]]                row[2] = avv_number[row[0]]                row[3] = tillage_in[row[0]]                row[4] = tllage_class[row[0]]                row[5] = depth_in[row[0]]                row[6] = depth_class[row[0]]                row[7] = downforce_lbs[row[0]]                row[8] = downforce_class[row[0]]                row[9] = cp_notch[row[0]]                row[10] = cp_class[row[0]]                # Update the cursor with the updated list                cursor.updateRow(row)        arcpy.management.CopyFeatures(fc_w_elev_soil, outputpath)        arcpy.AddMessage('Your ' + str(os.path.basename(outputpath) + ' file is ready.'))        # Change field name         arcpy.management.AlterField(outputpath, 'RASTERVALU', 'ElevClass', 'Elevation_class')        end = time.perf_counter()        arcpy.AddMessage(f'Execution took: {end-start} seconds')                return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return